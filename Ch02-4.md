앞에서 참조자의 이해를 위해 보여줬던 코드들은 어디까지나 학습을 위한 코드였다.
참조자의 활용에는 함수가 중요!
## Call-by-value & Call-by-reference
- call by value: 값을 인자로 전달하는 함수의 호출방식
- call by reference: 주소 값을 인자로 전달하는 함수의 호출방식
Swap함수로 실제로 두 변수의 값이 바꾸기 위해서는 call-by-reference 기반의 함수 사용.

## Call-by-address? Call-by-reference!
최근 들어 주소 값을 전달하는 Call-by-reference 형태의 함수호출이 Call-by-address라 불리는 경우를 종종 본다
- 이는 'C++의 참조자(reference) 기반의 함수호출'과의 구분을 위함

하지만, 필자는 이전의 방식, 주소 값을 전달하는 함수의 호출형태를 가리켜 여전히 Call-by-reference라 표현하고자 한다
- ```int * SimpleFunc(int * ptr){}``` 위의 함수 정의를 대부분 Call-by-reference라고 생각할 것이다
- 아래의 경우, Call-by-value라 해야 옳다
```
int * SimpleFunc(int * ptr){
    return ptr+1; //주소 값을 증가시켜서 반환
}
```
이 함수의 연산 주체는 값인데 그 값이 **주소 값**임. (주소 값에 1을 더한 결과를 반환하는 연산을 하니 포인터 연산의 결과로 4가 증가한다)
그래서 주소 값을 이용해서 함수 외부에 선언된 변수에 접근하는 Call-by-reference와는 거리가 멀다
- 이렇게 정의되면 의심할 여지없이 Call-by-reference
```
int * SimpleFunc(int * ptr){
    if(ptr==NULL)
        return NULL;
    *ptr = 20;
    return ptr;
}
```

>본래 C언어에서 말하는 Call-by-reference의 의미<br>
: 주소 값을 전달받아서, 함수 외부에 선언된 변수에 접근하는 형태의 함수호출

>C++에서는 함수 외부에 선언된 변수의 접근방법으로 두 가지가 존재<br>
    - 주소 값을 이용한 call-by-reference (얘를 call-by-address라고도 함)
    - 참조자를 이용한 call-by-reference

*필자는 Call-by-address라는 표현이 잘못되었다고 하는 것이 아님*
**Call-by-reference의 가장 큰 핵심은 함수 내에서 함수외부에 선언된 변수에 접근할 수 있다는 것!**

## 참조자를 이용한 Call-by-reference
*RefSwap.cpp*

## 참조자를 이용한 Call-by-reference의 황당함과 const 참조자
```
int num=24;
HappyFunc(num);
cout<<num<<endl;
```
- 위 함수에 대해 C언어의 관점이라면 100% 24가 출력된다
- C++에서는 참조자를 이용해 변경할 수 있으므로 얼마가 출력될 지 모른다
이게 참조자의 단점..!
- 코드의 분석과정에서 함수의 호출문장만 보고도 함수의 특성을 어느정도 판단가능해야 하는데 그게 안됨
함수의 원형을 확인하고 만약 참조자가 매개변수의 선언에 와있다면 함수의 몸체까지 확인해야 함
- 이러한 단점을 완벽히 해결하려면 참조자 기반의 함수정의를 하지 말아야 함.
- const 키워드를 이용하여 어느정도 극복이 가능하다.
```void HappyFunc(const int &ref){...}```
>따라서 다음의 원칙을 지켜주는 것이 좋다.<br> 
**함수 내에서, 참조자를 통한 값의 변경을 진행하지 않을 경우, 참조자를 const로 선언해서, 함수의 원형만 봐도 값의 변경이 이뤄지지 않음을 알 수 있게 한다**

## 반환형이 참조형(Reference Type)인 경우
*RefReturnOne.cpp*
>여기서 기억해야할 점.<br>
함수 RefRetFuncOne의 매개변수로 선언된 참조자 ref는 지역변수와 동일한 성격을 갖는다.<br>
즉, 함수를 반환하면 참조자 ref는 소멸된다

*RefReturnTwo.cpp*
- 이렇게 반환형이 참조형인 경우, 반환 값을 무엇으로 저장(one은 참조자에 저장했고 two는 변수에 저장)하느냐에 따라서 결과가 달라짐
*RefReturnThree.cpp*
- 실행결과를 보면 위의 two와 차이가 없다

하지만.
- 반환형이 참조형인 함수는 반환값을 ```int num2=Func(num1);```, ```int &num2=Func(num1);``` 이렇게 두 가지 형태로 저장할 수 있다
- 반환형이 기본자료형으로 선언된 함수는 반환값을 반드시 변수에 저장해야 한다 (참조자에 저장 안됨)

## 잘못된 참조의 반환
```
int& RetuRefFunc(int n){
    int num = 20;
    num+=n;
    return num;
}

int &ref=RetuRefFunc(10);
```
- 지역변수에 num에 ref라는 또 하나의 이름이 붙게 됨. 하지만, num은 소멸이 됨.
- 이렇게 되면 쓰레기값을 참조하게 됨(여기서 주의: num이 소멸된다고 상수인 30을 참조하는건 아님. 이미 num이라는 참조형 친구가 반환이 된거고 반환되면서 소멸하니까 쓰레기값이 됨)
- 컴파일러는 이에 대해 경고메시지만 주고 에러메시지를 주진 않음
- 또한, 아직 채 소멸되지 않은 찌꺼기 형태로 남아있는 데이터를 참조해서 정상적인 출력결과를 보이기도 하니 주의가 필요하다
***그래서 위의 함수처럼 지역변수를 참조형으로 반환해서는 안된다!!!***

## const 참조자의 또 다른 특징
- 참조하려는 변수가 상수화된 변수일 경우 참조자 선언도 마찬가지로 상수화해야 함
```
const int num=20;
const int &ref=num;
```
- const 참조자는 상수도 참조가 가능하다
```const int &ref=50;```

## 어떻게 참조자가 상수를 참조하냐고요!
>리터럴 또는 리터럴 상수<br>
```int num=20+30;``` 여기서 20, 30 같이 프로그램상에서 표현되는 숫자를 가리켜 '리터럴(literal)' 또는 '리터럴 상수(literal constant)'라고 함

- 리터럴 상수의 특징: 
임시적으로 존재하는 값; 다음 행으로 넘어가면 존재하지 않는 상수
(덧셈 연산을 위해서 20도 30도 모두 메모리 공간에 저장되어야 하지만 저장됐다고 해서 재 참조가 가능한 값은 아님.)
- 이러한 상수를 참조한다는 것은 이치에 맞지 않음
- ```const int &ref = 30;``` 이는 숫자 30이 메모리 공간에 계속 남아있을 때에나 성립이 가능한 문장임
그래서, C++에서는 위의 문장이 성립 가능하도록, const참조자를 이용해서 상수를 참조할 때 **'임시변수'**라는 것을 만듦
- 임시변수에 상수 30을 저장하고선 참조자가 이를 참조하게끔 한다
>왜 임시변수라는 잘 와닿지도 않는 개념까지 끌어들여서 상수의 참조를 가능하게 했을까? <br>
```
int Adder(const int &num1, const int &num2){
    return num1+num2;
}
```
위와 같은 함수에 인자의 전달을 목적으로 변수를 선언하는 것은 매우 번거로움<br>
그래서 임시변수의 생성을 통해 const 참조자의 상수참조를 허용함으로써, ```Adder(3,4)``` 이런 간단한 호출을 가능하게 함
